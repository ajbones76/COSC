https://net.cybbh.io/public/networking/latest/index.html
https://miro.com/app/board/o9J_klSqCSY=/
https://net.cybbh.io/-/public/-/jobs/851376/artifacts/modules/networking/slides/1-Network_Fundamentals.html
Day 1 - 3
Binary – off or on; true or false; 1 or 0 – how computer components relay information
Bits=1, Nibbles=4,Bytes=8,Half Word=16, Word=32, Double Word=64, Quad Word=128
Base2-binary, base10-decimal, base16-hex
Decode base64 if found
OSI Model
Application
Presentation
Session
Transport
Network
Data-Link: MAC, LLC
Physical

OSI Layer
PDU
Common Protocols
7 - Application
Data
DNS, HTTP, TELNET
6 - Presentation
Data
SSL, TLS, JPEG, GIF
5 - Session
Data
NetBIOS, PPTP, RPC, NFS
4 - Transport
Segment/Datagram
TCP, UDP
3 - Network
Packet
IP, ICMP, IGMP
2 - Data Link
Frames
PPP, ATM, 802.2/3 Ethernet, Frame Relay
1 - Physical
Bits
Bluetooth, USB, 802.11 (Wi-Fi), DSL, 1000Base-T
Ethernet Header: 0x0800-IPv4,0x0806-ARP,0x86DD-IPv6,0x8100-VLAN Tag
VLAN-multiple LANs on same switch
Anyone who receives ARP reply updates ARP table
ARP-IP to MAC
20B*8b=160b/32b=5 # words in IP Header
64 TTL-Linux, 128 TTL-Windows, 255 TTL-Cisco
Firewalking
ICMP-1, TCP-6, UDP-11
Fragmentation-breaks up single packet into multiple smaller packets
MTU-IHL * 4 = Data Fragments
Offset showing number of 8 bit chunks; Data Fragments/8=Offset Value
IPv4 zero/auto configuration-Automatic Private IP Addressing(APIPA)-RFC 3927-169.254.0.0/16
IPv6 zero/auto configuration-Stateless Address Autoconfiguration(SLAAC)-RFC 4862


TCP Three-Way handshake-SYN, SYN/ACK, ACK
Session Layer Protocols
Socks-client server exchange messages
PPTP/L2TP
SMB/CIFS-Netbios Dgram-UDP 138, Netbios Session-TCP 139
RPC-Running commands/system calls over network (NFS, XML, JSON, SOAP)
Presentation Layer-Translation, Formating, Encoding Encryption, Compression
Application Layer-Layer that user acts with directly
FTP active(Default)-client initiates connection with server; NAT and firewall traversal issues, complications with tunneling through SSH
FTP passive-client initiates both command and data connections, specifies both ports; solves issues related to Active mode, most often used in modern systems
PASV
retr <file>
stor<file>
from server
<file> (10,10,10,10,128,4)-IP and port-128*256=4
10.10.10.10:32772
Telnet-unsecure, plaintext; get a shell
SMTP-used for servers to communicate messages between each other
SSH-secure, emcrypted; user key, host key, session key
SFTP,SCP,tunneling,etc
Known-hosts database-collection of host keys that client and server use for mutual authentication
Conf file-settings that exist on client and server to dictate configuration of ssh and sshd /etc/ssh/sshd_config
SSH concerns:
using password authentication only, key rotation, key management, implementation specification(libssh,sshtrangerthings)
TACACS-Cisco remote login service
HTTP/HTTPS methods:
GET, HEAD, POST, PUT
HTTP/HTTPS status codes:
100,200,300,400,500-100 range: informational 200 range: everything went ok, 300 range: redirection, 400 range: user did something wrong, 500 range: server did something wrong
https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
POP-downloading mail (Go to post office)
IMAP-going to server and reading mail on server
DNS-UDP: Query, TCP: Zone Transfers
DHCP-hosts being assigned IP addresses; host asks for IP, router assigns IP
DHCPv4: DORA – Discover, Offer, Request, Ack
DHCPv6: SARR – Solicit, Advertise, Request, Reply
Router solicitation multicast: FF02::2
Client uses 68, server uses 67
TFTP-UDP, no interactive terminal; share router and switch configs from central location
NTP-network time protocol-make times universal
SNMP-centralized location for network
RADIUS-centralized login service/centralized authentication
RTP-establishing session for UDP; UDP acting like TCP connection

Switch Operation:
Fast Forward: Only reads destination MAC
Fragment Free: First 64 bytes
Store and Forward: Entire frame and FCS
CAM Table: area of non-volatile memory inside switch, shares relationships between MAC and ports
Q-in-Q: VLAN inside VLAN
0x88A8-Standard Double Tag, 0x9100-Non-standard Double Tag
First VLAN tag is 0x8100-be concerned, VLAN hopping
STP-eliminates single point of failure, eliminates broadcast storm-ARP request goes to everybody-stuck in loop of ARP requests, slows and crashes network
Root bridge-bridge priority of 0
Root ports-lead to root bridge
Designated ports-lead away from root bridge
Blocking state-prevents loops
RSTP-all BPDUs will come from root only and each switch will forward them out trunk ports
PVST, PVST+ : Cisco proprietary versions of STP and RSTP
Layer 2 Discovery protocols: CDP, FDP, LLDP
Trunk ports-used to communicate VLAN traffic
DTP
VTP-reduce administration of creating VLANS on all switches within a switched network; VTP sends VLAN information to all switches in a VTP domain
Port security: shutdown, restrict, protect
Switch separate collision domains
Routers separate broadcast domains
Ultimate route-routing table entry that has next-hop address, exit interface, or both
Level 1 route-route with subnet mask (CIDR) is equal to or less than the classful mask of network address; can be a:
network route-subnet mask equal to that of the classful mask
Class A-255.0.0.0/8
Class B-255.255.0.0/16
Class C-255.255.255.0/24
Supernet route-network route with mask smaller than classful mask
Default route-catch-all static route: 0.0.0.0/0
Parent route-level 1 network subnetted, can never be ultimate route
Level 2 route-child route subnets of a classful network addresse
DuckDuckGo, type in IP and cidr for subnet
Best route=longest match
Routing protocol-used by routers to communicate routing information with each other
Routed protocol-direct traffic, routed by routing protocols
Routers use administrative distance(AD) to determine best source route AD represents trustworthiness of route, lower the AD the more trustworthy
Metrics: Hop count, bandwidth, delay, load, MTU, reliability, cost, policy
Pros and cons of Static routing:

Dynamic Routing Protocols:
IGPs:
Distance Vector Routing Protocols:RIP, IGRP, EIGRP
Link-State Routing Protocols:OSPF, IS-IS
EGPs:
Path-Vector Routing Protocols: BGP
Pros and cons of dynamic routing:

Interior Gateway Protocols (IGP): Routing protocols that are used within an AS. Referred to as intra-AS routing. Organizations and service providers IGPs on their internal networks. IGPs include RIP, EIGRP, OSPF, and IS-IS.
Exterior Gateway Protocols (EGP): Used primarily for routing between autonomous systems(AS). Referred to as inter-AS routing. Service providers and large companies will interconnect their AS using an EGP. The Border Gateway Protocol (BGP) is the only currently viable EGP and is the official routing protocol used by the Internet.
Distance Vector protocols are simplistic in their operation. They share entire routing tables with their directly connected neighbors and from these shared tables they determine two factors:
Distance: This identifies how far away the destination network is from the router and is based on a metric such as the hop count, cost, bandwidth, delay, and more. It takes the learned distance from their neighbor, adds the distance to their neighbor, and this gives them a total distance.
Vector: This specifies the direction to the remote network. The router that advertised the route to the router is the one the router will need to send traffic to that will get the traffic to the remote network and the interface it was learned on.
Router using a distance vector routing protocol will not have complete knowledge of the network or the entire path to a remote network
Router configured with a link-state routing protocol can create a complete view of the network. This is built by gathering information from all of the other routers to build a network topology
BPFs:
All designated bit values must be set; no others can be set
Take DSCP  value * 4 = ip[1]&0xFC=112 if DSCP is 28
ip[6] & 0x20 = 0x20 || ip[6:2] & 0x1FFF > 0
ip[12:4] = 0x0A0A2801    #leave ip as hex
ip[12:4]&0xFFFFFF00=0x0A0A2800
tcpdump flags:
COMMAND: tcpdump filter syntax
FLAG: filter syntax
BPFCheck.pcap can be found on your INTERNET_HOST in /home/activity_resources/pcaps
To find the packet count, you can append | wc -l after your command. For example tcpdump -n "yourfilter" -r BPFCheck.pcap | wc -l

Commands
Day 1 & 2
Student#: student4
Command: ssh student@10.50.39.143 -X
Password: password

sudo tcpdump
sudo tcpdump -i eth0 -Xxvvn
sudo tcpdump -i eth0 -Xxvvn ‘not tcp port 22’
sudo tcpdump -i eth0 -XXvvn '(not tcp port 22) && udp port 68'
sudo tcpdump -i eth0 -XXvvn 'src host <IP>'
sudo tcpdump -XXvvnr /home/activity_resources/pcaps/Xtra.pcap
Berkely Packet Filter Syntax:
tcpdump {A} [B:C] {D} {E} {F} {G}
A = Protocol (ether | arp | ip | ip6 | icmp | tcp | udp)
B = Header Byte offset
C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
D = optional: Bitwise mask (&)
E = Operator (= | == | > | < | <= | >= | != | () | << | >>)
F = Result of Expression
G = optional: Logical Operator (&& ||) to bridge expressions
Filter down to bits, not just bytes:
ip[0] & 0x0F > 0x05
Day 4
Stream Sockets-connection oriented and sequenced; methods for connection establishment and tear-down. Used with TCP, SCTP, and bluetooth
Datagram Sockets-connectionless; designed for quickly sending and receiving data; UDP
Raw Sockets-direct sending and receiving of IP packets without automatic protocol-specific formatting; used in user applications when using elevated privilege levels
User Space Sockets: common sockets that do not require elevated privileges
Stream sockets
Datagram sockets
Kernel Space Sockets: access hardwae directly on behalf of user application, requires elevated privileges
Raw sockets

Network sockets using Python3
import socket
s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
FAMILY-AF_INET(default, ipv4), AF_INET6(ipv6), AF_UNIX
TYPE-SOCK_STREAM(default), SOCK_DGRAM, SOCK_RAW
PROTOCOL(Only need for raw sockets)-0(default), IPPROTO_RAW
https://docs.python.org/3/library/socket.html
https://docs.python.org/3/library/struct.html
https://docs.python.org/3/library/sys.html
B = 1 byte (Byte)
    • H = 2 bytes (Half Word)
    • 4s = 4 bytes (Word - Converted from string to binary)
STREAM Socket
#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ipaddr = ‘127.0.0.1’
port = 54321
s.connect((ipaddr, port))
s.send(b’Hello\n’)
response, conn = s.recvfrom(1024)
print(response.decode())
s.close()

echo "I got your message" | nc -l -p 12345
run script

DGRAM Socket
#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
ipaddr = ‘127.0.0.1’
port = 12345
s.sendto(b’Hello’, (ipaddr,port))
response, conn = s.recvfrom(1024)
print(response.decode())

echo "I got your message" | nc -l -p 12345 -u
run script

RAW Socket
#!/usr/bin/python3
# For building the socket
import socket
# For system level commands
import sys
# For establishing the packet structure (Used later on), this will allow direct access to the methods and functions in the struct module
from struct import *
# Create a raw socket.
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error as msg:
    print(msg)
    sys.exit()
packet = ''
src_ip = "10.1.0.2"
dst_ip = "10.3.0.2"
# Lets add the IPv4 header information
ip_ver_ihl = 69  # This is putting the decimal conversion of 0x45 for Version and Internet Header Length
ip_tos = 0           # This combines the DSCP and ECN feilds
ip_len = 0           # The kernel will fill in the actually length of the packet
ip_id = 1775       # This sets the IP Identification for the packet
ip_frag = 0          # This sets fragmentation to off
ip_ttl = 64          # This determines the TTL of the packet when leaving the machine
ip_proto = 16        # This sets the IP protocol to 16 (Chaos). If this was 6 (TCP) or 17 (UDP) additional headers would be required
ip_check = 0         # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip)  # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)  # inet_aton(string) will convert an IP address to a 32 bit binary number
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
message = b'This is a message'
packet = ip_header + message
# Send the packet
s.sendto(packet, (dst_ip, 0))
sudo tcpdump -vvX “ip[4:2]=1775”
sudo python3 ./raw_soc
Day 5
Active Recon-actively sending packets to network or host
Passive Recon-listens and wait for traffic, gathering info without direct interaction, lower risk of discovery, takes longer – identifies: IP addresses, sub-domains, external and third party sites, people and tech, content of interest, vulnerabilities
Internal Recon-inside the network
External Recon-outside the network

Passive internal-packet sniffers – ifconfig, arp, situational awareness commands
Situation Awareness Checklist:
hostname/uname -a
whoami/w
pwd
sudo -l -list what you can sudo
cat /etc/hosts and /etc/services
ps -elf
netstat -ntlpu          -listening ports    or          ss -ntlpu
ifconfig/ip/ip a for addresses
arp/ip neigh/ip n
route/ip route/ip r
check any other important directories as directed
if IP is in ip n and ip r, most likely router
Passive external-DNS lookups-resolves hostnames to IP addresses, whois, job site listings – allows for more efficient attacks and plans – commands: nslookup, dig; wayback machine, google searches-google dorking, shodan
Active internal-DNS Queries, ARP Requests
Active external-Network scanning – fping, hping3, arping, nmap, netcat
Varify what services are actually running on the ports
put box for anything found in nmap
first scan ports 21-23 and 80
if it says to scan high ports, use -p-

Day 5 Commands
DNS Queries:
dig ccboe.net           -       A records
dig ccboe.net AAAA              -       AAAA records
dig ccboe.net SOA               -       SOA records
dig ccboe.net NS                -       NS records
dig ccboe.net TXT               -       TXT records
dig AXFR @nsztm1.digi.ninja zonetransfer.me             -Zone Transfers only one uses TCP
whois <domain>
Network Scanning:
sudo nmap -sS 172.16.82.106             -       TCP SYN Scan
nmap -sV 172.16.82.106                  -       Version Scan
add -vv for verbose to see information during the scan
sudo nmap -sV 172.16.82.106 -vv -O
sudo nmap -sV 172.16.82.106 -vv -A              -Lot of info in 1 option
-T to speed up or slow down scan, 0-5: 0 slowest, 5 fastest, should use 4
sudo nmap -sV 172.16.82.106 -vv -A -T4 --min-rate 10000
sudo nmap 172.16.82.106 -vv -sU -T4 --min-rate 10000    -udp scan
-n will disable name resolution
sudo nmap 172.16.82.106 -vv -sU -T4 --min-rate 10000 -Pn                -treat target as if it’s up(need for tunneling)
sudo nmap 172.16.82.106-112 -vv -sU -T4 --min-rate 10000                -scan range
can also use cidr
sudo nmap 172.16.82.96/27 -vv -sU -T4 --min-rate 10000 -p 1-1024        -scan UDP ports 1-1024
-p -<max port> will start with first available port to max set
-p <min port>- scan all ports from min port
-p- scan all ports
Netcat:
nc -nzvw1 172.16.82.106 80
nc 172.16.82.106 80     -verify that the service is actually the service nc says on that port
-u for UDP scans
HTTP requests:
curl <ip>
wget <ip>
wget -r <ip>            -recursively search and get every file that server is hosting
wget -r ftp://<ip>      -specify ftp
wget -r <ip>:<port>             -specify port
Ruby Ping Sweep:
for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) ;done

open images
eom
eog
vyos:
see interfaces – show interface
Day 6
Common Methods for Data Transfer:
TFTP,FTP(Active and Passive)(21-command port, 20-data transfer),SFTP,SCP,FTPS
Netcat-file transfers, banner grabbing, port scanning, troubleshooting network connections
listeners need to be listening before client can connect
named pipes-can store data exist as a file until they are removed-mkfifo <pipe name>
netcat -e option for executing

Day 6 Commands
scp <options> <source> <destination>
<users@IP>:
Options:
-v - verbose mode
-p - provides estimated time and connection speed
-P - port – Specifies the port to connect to on the remote host. Note that this option is written with a capital ‘P’.
-C - enable compression
-l - limit bandwidth (counted in bits, ex: 100KB/s (100*8), specify the parameter as 800)
-r - recursively copy an entire directory
-3 - copies between two remote hosts are transferred through the localhost.  Without this option the data is copied directly between the two remote hosts.  Note that this option disables the progress meter
. means current directory

Netcat client send file
nc <IP> <port> < file
listener receives file
nc -lp <same port> > file
Netcat Relay
Create named pipe: mkfifo mypipe(pipename)
<nc command> 0<mypipe | <nc command> 1>mypipe   (command run on host being used as relay)
host 1: nc -lp 5454
host 2: mkfifo mypipe, nc <host 1 IP> 5454 0<mypipe | nc -lp 4343 1>mypipe
host 3: nc <Host 2 IP> 4343
Host 2 acts as go between/relay for host 1 and 3
Day 7
Port Range: 50400-50499
Local forwards start low work high, remote start high work low
-L:Local; -R:Remote
Local forwarding:
ssh -p <optional alt port> <user>@<pivot ip> -L <local bind port>:<tgt ip>:<tgt port> -NT
OR
ssh -L <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<pivot ip> -NT
Remote forwarding:
ssh <user>@<IP> -R <local port>:127.0.0.1:<port used>
Dynamic forwarding:
ssh <user>@<IP> -p <port> -D 9050 -NT
-NT: open terminal no longer accepts input
proxychains only proxy TCP traffic

IH>NMAP <Bob>
        Ports 22, 25 open
IH>Use netcat to verify service running on open port; nc Bob 22
        22-ProFTP, 25-SSH
IH>wget -r ftp://Bob:22
IH>ssh user1@Bob
Bob>Situational awareness – Found port 80 open
{IH>ssh user1@Bob -p 25 -L 50400:127.0.0.1:80 -NT
OR
Bob>ssh student@IH -R 50499:127.0.0.1:80 -NT}
IH>wget -r 127.0.0.1:(50400 or 50499)
IH>ssh user1@Bob -p 25 -D 9050 -NT
IH>proxychains <NMAP -Pn> Jerry,Thomas
        Jerry-21(FTP),23(Telnet),80(HTTP); Thomas-23(Telnet),80(HTTP)
IH>proxychains wget -r ftp://Jerry
IH>proxychains wget -r Jerry
IH>proxychains wget -r Thomas
IH>proxychains telnet Jerry
Jerry>Situational awareness
        22(SSH)
Jerry>ssh user1@Bob -p 25 -R 50498:127.0.0.1:22 -NT
IH>ssh user1@Bob -p 25 -L 50401:127.0.0.1:50498 -NT
IH>nc 127.0.0.1 50401
        OpenSSH
IH>user1@127.0.0.1 -p 50401
Jerry> (close ssh connection)
IH>ssh user1@127.0.0.1 -p 50401 -D 9050 -NT; won’t work because already have proxychains open, if close proxychains tunnels opened with proxychains will close, use proxychains for situational awareness; use static port forwards
(Close proxychains terminal)
IH>ssh user1@Bob -p 25 -L 50402:Jerry:23 -NT
IH>telnet 127.0.0.1 50402 (Tests previous command from IH to Jerry)
Jerry> ssh user1@Bob -p 25 -R 50498:127.0.0.1:22 -NT
IH>ssh user1@127.0.0.1 -p 50401
Jerry>(close connection)
IH>ssh user1@127.0.0.1 -p 50401 -D 9050 -NT
IH>proxychains <nmap -Pn> Joe OR proxychains ./scan.sh
        Joe-22,80,443
IH>proxychains nc Joe 22, nc Joe 80, nc Joe 443
        22(SSH),80(Telnetd),443(ProFTPd)
IH>proxychains wget -r ftp://Joe:443

What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets with at least the Dont Fragment bit set?
ip[6]&0x40=0x40
What is the Berkeley Packet Filter, using tcpdump, to capture all packets with a ttl of 64 and less, utilizing the IPv4 or IPv6 Headers?
ip[8]<=64||ip6[7]<=64
What is the Berkeley Packet Filter, using tcpdump, to capture traffic with a Source Port higher than 1024, utilizing the correct Transport Layer Headers?
tcp[0:2]>1024||udp[0:2]>1024
What is the Berkeley Packet Filter, using tcpdump, to capture all Packets with UDP protocol being set, utilizing the IPv4 or IPv6 Headers?
ip[9]=0x11||ip6[6]=0x11
What is the Berkeley Packet Filter, using tcpdump, to capture only packets with the ACK/RST or ACK/FIN flag set, utilizing the correct Transport Layer Header?
What is the Berkeley Packet Filter, using tcpdump, to capture all packets with an IP ID field of 213?
ip[4:2]=213
What is the Berkeley Packet Filter, using tcpdump, to capture all traffic that contains a VLAN tag?
ether[12:2]=0x8100
What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets relating to DNS?
tcp[0:2]=0x35||tcp[2:2]=0x35||udp[0:2]=0x35||udp[2:2]=0x35
What is the Berkeley Packet Filter, using tcpdump, to capture the initial packets from a client trying to initiate a TCP connection?
tcp[13]=0x02
What is the Berkeley Packet Filter, using tcpdump, to capture the response packets from a server listening on an open TCP ports?
tcp[13]=0x12
What is the Berkeley Packet Filter, using tcpdump, to capture the response packets from a server with closed TCP ports
tcp[13]=0x04
What is the Berkeley Packet Filter, using tcpdump, to capture all TCP and UDP packets sent to the well known ports?
tcp[2:2]<1024||udp[2:2]<1024
What is the Berkeley Packet Filter, using tcpdump, to capture all HTTP traffic?
tcp[0:2]=80||tcp[2:2]=80
What is the Berkeley Packet Filter, using tcpdump, to capture all telnet traffic?
tcp[0:2]=23||tcp[2:2]=23
What is the Berkeley Packet Filter, using tcpdump, to capture all ARP traffic?
ether[12:2]=0x0806
What is the Berkeley Packet Filter, using tcpdump, to capture if the "Evil bit" is set?
ip[6]&0x80=0x80
What is the Berkeley Packet Filter, using tcpdump, to capture any packets containing the CHAOS protocol within an IPv4 header?
ip[9]=0x10
What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets with the DSCP field of 37?
ip[1]&0xFC=0x94
What is the Berkeley Packet Filter, using tcpdump, to capture all IPv4 packets targeting just the beginning of potential traceroutes as it's entering your network. This can be from a Windows or Linux machine using their default settings?
ip[8]=1&&(ip[9]=0x11||ip[9]=0x01)
What is the Berkeley Packet Filter, using tcpdump, to capture all packets where the URG flag is not set and URG pointer has a value?
tcp[13]&0x20=0&&tcp[18:2]>0
What is the Berkeley Packet Filter, using tcpdump, to capture a TCP null scan to the host 10.10.10.10?
tcp[13]=0&&ip[16:4]=0x0A0A0A0A
What is the Berkeley Packet Filter, using tcpdump, to capture an attacker using vlan hopping to move from vlan 1 to vlan 10?
ether[12:4]&0xffff0fff=0x81000001&&ether[16:4]&0xffff0fff=0x8100000a
T3-10.50.42.216
T4-10.50.44.211
T5-10.50.40.12
1. ssh net5_student4@10.50.42.216 -L 50401:10.3.0.27:80 -NT
wget -r http://127.0.0.1:50401
2. ssh net5_student4@10.50.42.216 -D 9050 -NT
proxychains nmap 10.3.0.1 -Pn
proxychains nc 10.3.0.1 21; proxychains nc 10.3.0.1 80
proxychains wget -r ftp://10.3.0.1:21
3. telnet 10.50.44.211
4. ssh net5_student4@10.3.0.10 -R 50499:127.0.0.1:22 -NT
ssh net5_student4@10.50.42.216 -L 50403:127.0.0.1:50499 -NT
ssh net5_student4@127.0.0.1 -p 50403 -L 50404:10.2.0.2:80 -NT
wget -r http://127.0.0.1:50404
5. ssh net5_student4@127.0.0.1 -p 50403 -D 9050 -NT
proxychains wget -r ftp://10.2.0.2
6. ssh net5_student4@10.50.42.216 -D 9050 -NT
proxychains wget -r http://10.3.0.1
7. proxychains wget -r ftp://10.3.0.27
8. ssh net5_student4@10.50.42.216 -L 50406:10.4.0.1:22 -NT
ssh net5_student4@127.0.0.1 -p 50406 -D 9050 -NT
proxychains wget -r ftp://10.5.0.1
10. proxychains wget -r ftp://10.5.0.57

1. SSH-01>ssh student@10.50.39.143 -R 50495:127.0.0.1:22 -NT
IH>net5_student4@127.0.0.1 -p 50495 -D 9050 -NT
http://10.50.20.162:8000/challenges#2.%20Data%20Collection%20-%20High%20port

https://net.cybbh.io/public/networking/latest/index.html

Less learning how to directly defend the network and more of the network at basic level
192.168.245.184

Goodbye my friend, you messed up again.
Lewis(10) - 10.50.45.241
Bage(2) - 10.50.39.51
Joey(8) - 10.50.32.146
Siercke(15) - 10.50.32.224
Crane(5) - 10.50.40.141
McKee(11) - 10.50.39.27
My stack(19) - 10.50.27.42
(3) 10.50.35.32
(16) 10.50.24.82
Huss - (7) 10.50.43.110
(1) 10.50.31.15
(6) 10.50.43.232
(20) 10.50.27.170
Stephens(17) - 10.50.37.223
(9) 10.50.26.189
(14) 10.50.20.73
Reggie (13) 10.50.35.39
Bonestroo - (4) 10.50.39.143
(12) 10.50.44.240
Port range 51500-51599
c 6,005.64
s 42.35
I 2,119.16
Network Fundamentals
______________________________________________________________________________________________________________________

a hex character is a nibble or 4 bits
2 hex characters is a byte
2 half words are a word
a long word is two words
a quad word is two long words

Communication happens through encapsulation and decapsulation depending on which layer of the OSI model it is going through
Looking at the graph there are different examples of which layers of the OSI model certain applications work through
Data link sub-layers MAC and LLC
The destination is sent first over ethernet beclause when the frames are going through switches it makes it faster, because they don't need a source just a destination

Common Ethertypes controlled by IANA.org:

        0x0800 - IPv4

        0x0806 - ARP

        0x86DD - IPv6

        0x8100 - VLAN Tagging 802.1q

The default value of the IHL is 5. but why?
20B or 160b because it is broken into words (32b) making it 5
Understand headers and how to read them
Linux 64 Windows 128 Cisco 255 on the TTL
Linux just uses icmp and Windows also uses UDP
1 for icmp, 6 for tcp and, 11 for udp

        Flags                        Frag Offset
0        0        0        |
Res      DF       MF
On the fragmlentation process the offset will go up by number of 8 bits chunks which is why it's going up by 185 instead of 1480

Don't worry about all that noise wireshark got you baby
IPv4 we got APIPA 169.254.0.0/16

Session layer has SOCKS
or Socket Secure
PPTP is a very old and insecure vpn developed by Microsoft
L2TP Cisco and Microsoft combined to create this
SMB/CIFS is Server Message Block shit
RPC is running commands or system calls over the network

Presentation, the difference between a Villain and a Super Villain
Translation
Formating
Encoding (ASCII,EBCDIC,HEX,BASE64)
Encryption (Symmetric or Asymmetric)
Compression

Application Layer THE BEEFY BOI
FTP gives you a prompt
FTP active, like calling the pizza place and telling them to deliver it
FTP passive, calling the pizza to order it, but you still have to go pick it up

Telnet is an insecure method of getting a shell





Spanning Tree Protocol
Eliminate single point of failure
ARP requests can cause a broadcast storm with a bunch of interconnected switches
One switch directly connected to the router is the root bridge
Setting alternate ports to a blocking state can stop a broadcast storm
There's also a Rapid STP which speeds up the setup process
Cisco versions of STP
Per VLAN Spanning Tree (PVST)
Per VLAN Spannning Tree Plus (PVST+)

Layer 2 Discovery Protocols
Cisco Discovery Protocol (CDP)
Foundry Discovery Protocol (FDP)
Link Layer Discovery Protocol (LLDP)


Dynamic Trunking Protocol
Trunk ports are what connect different VLANS


VLAN Trunking Protocol
Whatever updates are made to the VTP are pushed out to all other VLANs in the VTP domain


Port Security
Modes
 - Shutdown
 - Restrict
 - Protect

Switches separate collision domains
Routers separate broadcast domains
WE ARE NOT MAKING ROUTER CONFIGS
Subnetting is dividing networksNetwork Fundamentals
______________________________________________________________________________________________________________________

Supernetting is combining networks, trading network bits for host bits
DuckDuckGo.com can subnet for you
The lookup process is based off what is the closest match
RIP, EIGRP (USMC), OSPF (ARMY), BGP (Internet)
Having multiple routers is good for backups and reducing a single point of failure
Some protocols for these are
Hot Standby Router Protocol (HSRP)
Virtual Router Redundancy Protocol (VRRP)
Gateway Load Balancing Protocol (GLBP)

Administrative Distance
Tells the router how much it should trust the route it is looking at

Metrics
Hop
Bandwith
Delay
Load
Maximum Transmission Units
Reliability
Cost
Policy

Static Routing
Does not send updates
No bandwith used and minimal system resources
Data path is pre-determinied
Time consuming and prone to error in configuring
Administrator must intervene during any network outages
Does not scale well for large growing networks

Dynamic Chad Routing
Only worry about BGP for Exterior Gateway Protocols
Look at the table
Advantages
        -Easier to configure and maintain network
        -Intervention not needed with network outages
        -Scales very well for large networks
Disadvantages
        -Consumes bandwidth and system resources
        -Updates can be intercepted
        -Data path is not pre-determined

IGP and EGP
OSPF, RIPv2, EIGRP, and ISIS can all communicate together through BGP
Distance Vector and Link State

Clients talk from port 68 to 67 when using DHCP

BGP
Road-map of the Internet
Routes traffic between Autonomous System (AS) Number
Advertises IP CIDR address blocks
Establishes Peer relationships
Complicated configuration
Complicated and slow path selection
How does it work?
Advertise a more specific route, like how a /24 is more specific than a /16
Follows shorter route
Hijacking
        1. Illegitimate advertising of addresses
        2. BGP propagates false information
        3. Prupose
                -stealing prefixes
                -monitoring traffic
                -intercept (and possibly modify) Internet traffick
                -'black holing' traffic
                -perform MitM
How to prevent
Ip prefix filtering
BGP hijacking detection
  - Track the change in TTL of incoming packets
  - Incresed round trip time (RTT) which increases latency
  - Monitoring misdirected traffic
BGPSec

Capture library
Using things like Libpcap, WinPcap, or NPCAP


TCPDUMP
sudo tcpdump -i eth0 -XXvvn '(not tcp port 22) && (udp port 68)'
sudo tcpdump -i eth0 -XXvvn 'src host 10.10.0.40 && not tcp port 22'
sudo tcpdump -XXvvnr /home/activity_resources/pcaps/Xtra.pcap

when trying to filter for the DSCP multiply it by 4, which is why  is true
ip[6:2] & 0x1FFF !=0
ip[12:4] is for source ip addresses
ip[16:4] is for destination ip address
ip[12:4]=0x0A0A2801
ip[12:4]&0xFFFFFF00=0x0A0A2800 this works as a subnet mask


Ipv6 and 4 with ttl less than 64
ip[8]<=64||ip6[7]<=64

Don't fragment bit
ip[6]&0x40 = 0x40

Transport higher than 1024
tcp[0:2]>0x400||udp[0:2]>0x400

all packets with the udp protocol
ip[9]=0x11||ip6[6]=0x11

IP ID field of 213
ip[4:2]=213

Vlan tag
ether[12:2]=0x8100

question DNS
tcp[2:2]=0x40||udp[2:2]=0x40||tcp[0:2]=0x40||udp[0:2]=0x40

initial packet from tcp
tcp[13]=0x02

response packets from servers
tcp[13]=0x12

response packets from a server with closed tcp ports
tcp[13]=0x04

tcp and udp to well known ports
tcp[2:2]<1024||udp[2:2]<1024

HTTP
tcp[0:2]=80||tcp[2:2]=80

telnet traffic
tcp[0:2]=23||tcp[2:2]=23

arp traffic
ether[12:2]=0x0806

Evil bit
ip[6]&0x80=0x80

CHAOS
ip[9]=0x10

DSCP field of 37
ip[1]&0xFC=0x94

Traceroutes
ip[8]=1&&(ip[9]=0x11||ip[9]=0x01)

URG flag not set and pointer has a value
tcp[13]&0x20=0&&tcp[18:2]>0

TCP null scan to host 10.10.10.10
tcp[13]=0&&ip[16:4]=0x0A0A0A0A0A

Vlan hopper
ether[12:4]&0xffff0fff=0x81000001&&ether[16:4]&0xffff0fff=0x8100000a







Network Programming
______________________________________________________________________________________________________________________

Scket types
1. Stream
Secure connection with a 3-way handshake

2. Datagram
UDP/Yeeter, sprays prays and hopes for the best

3. Raw
Different cause it raw dogs in with the kernel rather than in user space


Sockets are the no shit way networking works, ssh uses sockets. Sockets are just making a connection and whatever protocol they are built on

User Space Applications
tcpdump or wireshark to read a file
nmap with no switches
netcat to create a listener above the well known range
using /dev/tcp or /dev/udp to transmit

Kernel Space Applications
using tcpdump or wiresharks on the wire
Using nmap for OS id or to set flags
netcat to create a listener

import socket
s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)
*Family/Type/Protocol will be changed with whatever we're trying to create*

socket.socket([*family*[,*type*[*proto*]]])

Family Constants
AF_INET, AF_INET6, AF_UNIX
Type Constants
SOCK_STREAM, SOCK_DGRAM, SOCK_RAW
Proto Constants
0, IPPROTO_RAW

Raw sockets
Are used to testing specific defenses, avoiding them, and to be sneaky









#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ipaddr = '127.0.0.1'
port = 54321
s.connect((ipaddr, port))
s.send(b'Hello\n')
#b is to send a bytes like object
response, conn = s.recvfrom(1024
#Creating the buffer size for the response
print(response.decode())
#take bytes like object and decode it into UTF-8
s.close()

#!/usr/bin/python3
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
ipaddr = '127.0.0.1'
port = 12345
s.sendto(b'Hello', (ipaddr,port))
response, conn = s.recvfrom(1024)
print(response.decode())


#!/usr/bin/python3
import socket
#system level commands
import sys
#Allows the creation of packet struture
from struct import *
#Create the raw socket
try:
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW
except socket.error as msg:
        print(msg)
        sys.exit()
packet = ''
src_ip "10.1.0.2"
dst_ip = "10.3.0.2"
#IP Header variables
ip_ver_ihl = 69      #Combined decimal value of 0x45 for IHL and Version
ip_tos = 0           # This combines the DSCP and ECN feilds
ip_len = 0           # The kernel will fill in the actually length of the packet
ip_id = 12345        # This sets the IP Identification for the packet
ip_frag = 0          # This sets fragmentation to off
ip_ttl = 64          # This determines the TTL of the packet when leaving the machine
ip_proto = 16        # This sets the IP protocol to 16 (Chaos). If this was 6 (TCP) or 17 (UDP) additional headers would be required
ip_check = 0         # The kernel will fill in the checksum for the packet
ip_srcadd = socket.inet_aton(src_ip) #Converts the IP address to a 32 bit binary number
ip_dstadd = socket.inet_aton(dst_ip)
ip_header = pack('!BBHHHBBH4s4s' , ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)
message = b'Networking is fun!'
packet = ip_header + message
# Send the packet
s.sendto(packet, (dst_ip, 0))








Network Reconnaissance
______________________________________________________________________________________________________________________



Active scanning
Network Scanning DNS Queries / Arp Requests
External                       Internal

Passive scanning
DNS Lookups Whois Job Site Listings / Packet Sniffers
External                              Internal

Passive recon is about gathering info about targets without direct interaction, is more difficult but more sneaky
Involves identifying IP addresses and subdomains, any external or third party sites, people and technologies, content of interest, and vulnerabilities
Tools are WHOIS, Job site listings, phone numbers, google searches, passive OS fingerprinting nslookup, dig
The internet wayback machine

dig axfr @nsztm1.digi.ninja zonetransfer.me
whois ccboe.net
Google Dorking
*ccboe.net -site:*.ccboe.net
site:*.ccboe.net "Powered by"
Shodan
- is a repository of web accessable vulnerable devices, cost money, and can lead to trouble

Active external recon
Different strategies, Remote to Local, Local to Remote, Local to Local, Remote to Remote
Scanning approach, aim (wide range target scan or target specific) and method (single source scan or distributed)
Broadcast ping and ping sweep, arp scan, syn scan, full connect scan, null scan, fin scan, xmas tree scan, UDP scan
ACK/Window scan, RPC scan, FTP scan, decoy scan, OS fingerprinting scan, version scan, protocol ping, discovery probes, idle scan
FTP bounce scan, maimon scan, ICMP echo discovery probe, Timestamp Discovery Probe, Netmask Request Discovery probe,
SCTP INIT Scan
Tools fping, hping3, arping, nmap, netcat
nmap by default does a full connect scan, scans the top 1000 ports used by everyone and host discovery
Syn scan is with -sS and using sudo, with this verify what services are actually running
Version scan is with -sV which will check what service is actually running, with a -vv makes it verbose, and -O adds OS
nmap IP -vv -A -p 1-1024 or even -1024
nmap ip -T4 --min-rate 10000 makes it loud but faster
A -n will disable name resolution on nmap
namp ip -vv -sU -T4 --min-rate 10000 -Pn
nc -nzw1
-n no name resolution, -z port scanning mode, I/O mode using TCP, -w for wait for 1 second
curl will show the html, wget will download it adding -r gives you more
wget -r ftp://172.16.82.112:4444

Situational awareness
1. hostname / uname -a
2. whoami, w
3. pwd
4. sudo -l
5. cat /etc/services & /etc/hosts
6. ps -elf
7. netstat -ntlup / ss -ntlup
8. ifconfig / ip addr or ip a
9. arp / ip n or neigh
10. route / ip route or r
11. Check any important directories as directed

for ping sweep
for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) ;done

21-23 80






Movement, Redirection, and Data Transfer
______________________________________________________________________________________________________________________

TFTP
Small and simple communication
FTP
Active mode
        The pizza is delivered
Passive mode
        You go get the pizza
No matter what with FTP there are two ports being used. The command port (21) and the port used for the actual data transfer
SFTP
SSH File Transfer Protocol, has a higher range of features over SCP like resuming interrupted transfers, directory listings, and remote file removal.
FTPS
File Transfer Protocol Secure
        has an implicit mode and explicit mode
        implicit has encryption at all times over ports 990 and 989
        explicit mode uses port 21 and can be secure or unsecure
SCP
uses port 22 and ssh but is non interactive
scp <options> <source> <destination>
scp -P <port>
scp -r <recursively copy a directory>
scp -3 <3 way communication>
scp file.txt <user>@<ip address>:<path in relation to user home directory>
scp <user>@<IP>:/etc/ssh/sshd_config .

NETCAT
Uses network socket connections to read and write data
Can be used for metasploit shells or banner grabbing

Client (seds file): nc 10.2.0.2 9001 < file.txt
Listener (receives file): nc -l -p 9001 > newfile.txt

named pipes
nkfifo <name of pipe>

FOR RELAY
<nc command> 0<piper | <nc command> 1>piper

on one machine do nc -lp 5454
on another do nc 10.10.0.40 4343
on the IH machine nc 172.16.82.106 5454 0<piper | nc -lp 4343 1>piper



Local and Dynamic SSH Tunneling
Local port forwarding
ssh -p <optional alt port> <user>@<pivot ip> -L <local bind port>:<tgt ip>:<tgt port> -NT
or
ssh -L <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<pivot ip> -NT

SSH Local Port Forwarding

    Creates a local port (1111) on the local host that forwards to a target machine’s port 80.

ssh student@172.16.82.106 -L 1111:localhost:80 -NT

or

ssh -L 1111:localhost:80 student@172.16.82.106 -NT

SSH Local Port Forwarding Through a Local Port

Internet Host:
ssh student@172.16.1.15 -L 1111:172.16.40.10:22 -NT
ssh student@localhost -p 1111 -L 2222:172.16.82.106:80 -NT
firefox localhost:2222

    Creates an additional local port on the local host that forwards to a target machine through the previous channel created.

SSH Dynamic Port Forwarding

    Syntax

ssh -D <port> -p <alt port> <user>@<pivot ip> -NT

    Proxychains default port is 9050

    Creates a dynamic socks4 proxy that interacts alone, or with a previously established remote or local port forward.

    Allows the use of scripts and other userspace programs through the tunnel.

SSH Dynamic Port Forwarding 1-Step

Blue Private Host-1:
ssh student@172.16.82.106 -D 9050 -NT

proxychains ./scan.sh
proxychains ssh student@10.10.0.40

Second Pivot External Active Recon
tp4
11.1
SSH Local Port ForwardingSyntaxssh -p <optional alt port> <user>@<pivot ip> -L <local bind port>:<tgt ip>:<tgt port> -NT or ssh -L <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<pivot ip> -NT

Dynamic port forwarding
ssh -D <port> -p <alt port> <user>@<pivot ip> -NT

SSH Remote port forwarding
ssh -p <optional alt port> <user>@<remote ip> -R <remote bind port>:<tgt ip>:<tgt port> -NT
or
ssh -R <remote bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<remote ip> -NT

L -> <-R

BOARD STUFF
IH> <nmap> Bob
IH> nc Bob 22
        ProFTPd
        nc Bob 25
        OpenSSH
IH>  wget -r ftp://Bob:22
IH>  ssh user1@Bob
Bob> *perform situational awareness*
IH>  ssh user1@Bob -p 25 -L 51000:127.0.0.1:80 -NT
Bob> ssh student@IH -R 51099:127.0.0.1:80 -NT
IH>  wget -r http://127.0.0.1:51000 or 51099
IH>  ssh user1@BOB -p 25 -D 9050 -NT
IH>  proxychains <nmap -Pn> Jerry,Thomas
IH>  proxychains wget -r gtp://Jerry
IH>  proxychains telnet Jerry
Jerry>  ssh user1@Bob -p 25 -R 51098:127.0.0.1:33 -NT
IH>  ssh user1@Bob -p 25 -L 51001:127.0.0.1:51098
IH>  nc 127.0.0.1 51001
        OpenSSH
IH>  ssh user1@127.0.0.1 -p 51001
Jerry> exit
IH>  ssh user1@127.0.0.1 -p 51001 -D 9050 -NT *close the old connection to use the 9050 port*
IH>  ssh user1@Bob -p 25 -L 51002:Jerry:23 -NT
IH>  telnet 127.0.0.1 51502
Jerry> ssh user1@Bob -p 25 -R 51098:127.0.0.1:22 -NT
IH>  ssh user1@127.0.0.1 -p 51001
Jerry> exit
IH>  ssh user1@127.0.0.1 -p 51001 -D 9050 -NT
IH>  proxychains <nmap> -Pn Joe or proxychains ./scan.sh
IH>  proxychains nc Joe 22
        OpenSSH
IH>  proxychains nc Joe 80
        Telnet
IH>  proxychains nc Joe 443
                ProFTPd
IH>  proxychains wget -r ftp://Joe:443





~/recon
________
Bob:22/
127.0.0.1:51000/
Jerry/
Thomas/
Joe:443/

51000 -> Bob:80
51099 -> Bob:80
51001 -> Bob:51098
51095 -> Jerry:22
51002 -> Jerry:23
51098 -> Jerry:22
9050  -> *

-NT makes it so the terminal no longer accepts input


when digging around or Passive Recon Methodology
Hostname
interfaces and subnets
        ip a
        ifconfig
Neighbors
        ip n
        arp -a
Files of interest
        find / flags 2>/dev/null
Other listening ports
        netstat -ntlp
        ss -ntlp
Available Tools
        which tcpdump wireshark nmap telnet get curl ping
NET RECON
Host Discovery
        nmap nc scan script ping sweep
Port Discovery
      nmap nc scan script
Port Validation
        Banner grabbing using nc
Follow-on actions based on ports found
        If 22 or 23 CONNECT and PASSIVE RECON
        If 21 or 80 wget -r IP or wget -r ftp://ip or firefox
SCAN METHODOLOGY
Quick Scan Ports 21-23, 80
Specific ports based on hints found
Wel known port range
        0-1023
Chunks of 2000 or first 10000
Hail Mary - Scan all ports (65535)




using sudo nmap -Pn 192.168.0.20,30,40,200 -T4 -p 21-23,80

T3 (Atropia) Float IP address is - 10.50.42.216

T4 (Pineland) Float IP address is - 10.50.44.211 (Note - You can only telnet here to act as an insider, this will not be a routed path)





1.
ssh net5_student10@10.50.42.216 -L 51000:10.3.0.27:80 -NT
 wget -r http://127.0.0.1:51000

2.
ssh net5_student10@10.50.42.216 -D 9050 -NT
proxychains wget -r ftp://10.3.0.1

3.
telnet 10.50.44.211

4.
IH> telnet 10.50.44.211
pineland> ssh net5_student10@10.3.0.10 -R 51099:localhost:22 -NT
IH> ssh net5_student10@10.50.42.216 -L 51001:localhost:51099 -NT
IH> ssh net5_student10@localhost -p 51001 -L 51002:10.2.0.2:80 -NT
IH> wget -r http://127.0.0.1:51002
IH> cat 127.0.0.1\:51002/index.html

5.
ssh net5_student10@127.0.0.1 -p 51001 -D 9050 -NT
proxychains wget -r ftp://10.2.0.2

6.
ssh net5_student10@10.50.42.216 -D 9050 -NT
proxychains ./scan.sh
proxychains wget -r http://10.3.0.1
cat 10.3.0.1/index.html

7.
proxychains wget -r ftp://10.3.0.27
cat 10.3.0.27/flag.txt

8.
ssh net5_student10@10.50.42.216 -L 51006:10.4.0.1:22 -NT
ssh net5_student10@127.0.0.1 -p 51006 -D 9050 -NT
proxychains wget -r ftp://10.5.0.1


9.
proxychains wget -r http://10.5.0.1

10.
proxychains wget -r ftp://10.5.0.57

11.
proxychains wget -r http://10.5.0.57

Data Collection
telnet 10.50.40.12

1.
data-collection-net-ssh-01> ssh student@10.50.45.241 -R 51097:127.0.0.1:22 -NT
IH> ssh net5_student10@127.0.0.1 -p 51097 -D 9050 -NT
IH> proxychains wget -r http://127.0.0.1

2.
SSH 0-1> for i in {1..254} ;do (ping -c 1 192.168.0.$i | grep "bytes from" &) ;done 2>/dev/null
IH> proxychains nmap -T4 -sV -Pn 192.168.0.30
IH> proxychains nc 192.168.0.30 4444

3.

4.
IH> proxychains wget -r ftp://192.168.0.20

5.
IH> ssh net5_student10@127.0.0.1 -p 51097 -L 51008:192.168.0.20:3333 -NT
IH> ssh net5_student10@127.0.0.1 -p 51008 -D 9050 -NT
IH> proxychains wget -r ftp://192.168.0.50

6.
IH> ssh net5_student10@127.0.0.1 -p 51097 -D 9050 -NT
IH> wget -r http://192.168.0.40

7.
found in the 192.168.0.40 hint

8.

9.
IH> ssh net5_student10@127.0.0.1 -p 51097 -L 51008:192.168.0.20:3333 -NT
IH> ssh net5_student10@127.0.0.1 -p 51009 -D 9050 -NT
IH> proxychains wget -r http://172.16.0.60

10.
IH> ssh net5_student10@127.0.0.1 -p 51097 -L 51009:192.168.0.40:5555 -NT
IH> ssh net5_student10@127.0.0.1 -p 51009 -L 51010:172.16.0.60:23 -NT
IH> telnet 127.0.0.1 51010
ssh-06> ssh net5_student10@192.168.0.40 -p 5555 -R 51095:127.0.0.1:22 -NT
IH> ssh net5_student10@127.0.0.1 -p 51097 -L 51011:192.168.0.40:51095 -NT ??
IH> ssh net5_student10@127.0.0.1 -p 51009 -L 51011:127.0.0.1:51095 -NT
IH> ssh net5_student10@127.0.0.1 -p 51011 -D 9050 -NT
IH> ssh net5_comrade10@127.0.0.1 -p 51011 -L 51012:172.16.0.90:2222 -NT
IH> ssh net5_comrade10@127.0.0.1 -p 51012 -D 9050 -NT
IH> proxychains telnet 172.16.0.100
DC-net-SSH-10> tcpdump -X icmp






Network Analysis
______________________________________________________________________________________________________________________


Wireshark
TCPDUMP
Fingerprinting and host identification is done using POF (Passive OS Fingerprinting)
You can find it by doing
IH> more /etc/p0f/p0f.fp
We can use Libpcap, WinPcap, and NPCAP
We do a week for baselining, to understand when people are supposed to be at work and when they aren't, and what is the norm or unusual.
Wireshark Expert information could be useful on CTFD
Ctrl+F for string use The display filter for more help


sudo tcpdump -r analysis-demo.pcap "tcp[13]=0x02" | awk '{print $3}' | cut -d. -f1,2,3,4 | sort -n | uniq





Full Packet Capture Data is a pcap
Session Data
        sflow is for switches
        NetFlow pulls all the ip information or router
Statistical Data
Packet String Data
Alert Data
Log Data

Sensors
        In-Line goes through our machine
        Passive gets data that we aren't in the middle of
Data Collection
        TAP
        SPAN
        ARP Spoofing (MitM) is a gratuitous reply
Indicator of Attack (IOA)
        Proactive
        A series of actions that are suspicious together
        Focus on Intent
        Looks for what must happen
                Code execution, persistence, lateral movement, etc.



33.
meterpreter

34.
ruby

35.













Network Traffic Filtering
______________________________________________________________________________________________________________________






sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
sudo iptables -A INPUT -p tcp --sport 22 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
sudo iptables -A INPUT -p tcp -m multiport --ports 6010,6011,6012 -j ACCEPT
sudo iptables -A OUTPUT -p tcp -m multiport --ports 6010,6011,6012 -j ACCEPT
sudo iptables -P INPUT DROP
sudo iptables -P OUTPUT DROP
sudo iptables -I INPUT -s 172.16.82.106 -j DROP
sudo iptables -I OUTPUT -d 172.16.82.106 -j DROP
sudo iptables -A INPUT -s 172.16.82.112 -j ACCEPT
sudo iptables -A OUTPUT -d 172.16.82.112 -j ACCEPT
sudo iptables -L -v
sudo iptables -A INPUT -m state --state INVALID -j DROP
sudo iptables -A INPUT -f -j DROP
sudo iptables -A INPUT -i eth0 -p tcp --syn -m limit --limit 10/second -j ACCEPT
sudo iptables-save > cctcipt.conf
sudo iptables-restore < cctc.conf -v


FROM IH
sudo apt-get install nftables
sudo nft list tables




FROM BH1
sudo nft list tables
sudo nft add table ip BH1
sudo nft flush table ip BH1
sudo nft delete table ip filter
sudo nft add chain ip BH1 input { type filter hook input priority 0\; policy accept\; }
sudo nft add chain ip BH1 output { type filter hook output priority 0\; policy accept\; }
sudo nft list table ip BH1
sudo nft insert rule ip BH1 input tcp dport 22 accept
sudo nft insert rule ip BH1 input tcp sport 22 accept
sudo nft insert rule ip BH1 output tcp dport 22 accept
sudo nft insert rule ip BH1 output tcp sport 22 accept
sudo nft add rule ip BH1 input tcp dport { 6010,6011,6012 } ct state { new, established } accept
sudo nft add rule ip BH1 input tcp sport { 6010,6011,6012 } ct state { new, established } accept
sudo nft add rule ip BH1 output tcp dport { 6010,6011,6012 } ct state { new, established } accept
sudo nft add rule ip BH1 output tcp sport { 6010,6011,6012 } ct state { new, established } accept
sudo nft add chain ip BH1 input { type filter hook input priority 0\; policy drop\; }
sudo nft add chain ip BH1 output { type filter hook output priority 0\; policy drop\; }
sudo nft add rule ip BH1 input ip saddr 172.16.82.112 drop
sudo nft add rule ip BH1 output ip daddr 172.16.82.112 drop
sudo nft insert rule ip BH1 input ip saddr 10.10.0.40 accept
sudo nft insert rule ip BH1 output ip daddr 10.10.0.40 accept
sudo nft list table ip BH1 -a
sudo nft add rule ip BH1 input position 37 ip saddr 172.16.82.112 drop
sudo nft add rule ip BH1 output position 38 ip daddr 172.16.82.112 drop
sudo nft delete rule ip BH1 input handle 35
sudo nft delete rule ip BH1 output handle 36
sudo nft add rule ip BH1 input ct state invalid drop
sudo nft add rule ip BH1 input ip frag-off != 0 drop
sudo nft add rule ip BH1 input tcp flags syn limit rate 10/second accept
sudo nft list ruleset > nftable.rules
sudo nft add chain ip BH1 input { type filter hook input priority 0\; policy accept\; }
sudo nft add chain ip BH1 output { type filter hook output priority 0\; policy accept\; }
sudo nft list table ip BH1
sudo nft flush table ip BH1
sudo nft -f nftable.rules




NAT and PAT w/ IPTABLES

snat
        postrouting
        input

masquerade
        postrouting

dnat
        prerouting
        output

redirect
        prerouting
        output
Source NAT w/ iptables
iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to 1.1.1.1

Destination NAT w/ iptables
iptables -t nat -A PREROUTING -i eth0 -j DNAT --to 10.0.0.1

Source PAT w/ iptables
iptables -t nat -A POSTROUTING -p tcp -o eth0 -j SNAT --to 1.1.1.1:9001

Destination PAT (Port Forwarding) w/ iptables
iptables -t nat -A PREROUTING -p tcp -i eth0 -j DNAT --to 10.0.0.1:8080


NAT and PAT w/ nftables
nft add table NAT
nft add chain NAT PREROUTING {type nat hook prerouting priority 0 \; }
nft add chain NAT POSTROUTING {type nat hook postrouting priority 100 \; }

Create the NAT rules
nft add rule NAT POSTROUTING ip saddr 10.1.0.2 oif eth0 snat 144.15.60.11
nft add rule NAT PREROUTING iif eth0 tcp dport { 80, 443 } dnat 10.1.0.3
nft add rule NAT POSTROUTING ip saddr 10.1.0.0/24 oif eth0 masquerade
nft add rule NAT PREROUTING tcp dport 80 redirect to 8080

T@bl3sth@tF1lt3r
 N@tF1lt3rsf0rL1f3
i_am_filtering_your_noise




T1
BH1> sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A INPUT -p tcp --sport 22 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A INPUT -p tcp --dport 23 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A INPUT -p tcp --sport 23 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --dport 23 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --sport 23 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A INPUT -p tcp --dport 3389 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A INPUT -p tcp --sport 3389 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --dport 3389 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --sport 3389 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -P INPUT DROP
BH1> sudo iptables -P OUTPUT DROP
BH1> sudo iptables -P FORWARD DROP
BH1> sudo iptables -A INPUT -s 10.10.0.40 -p icmp -j ACCEPT
BH1> sudo iptables -A OUTPUT -d 10.10.0.40 -p icmp -j ACCEPT
BH1> sudo iptables -A INPUT/OUTPUT -p tcp -m multiport --ports 6579,4444 -j ACCEPT
BH1> sudo iptables -A INPUT/OUTPUT -p udp -m multiport --ports 6579,4444 -j ACCEPT
BH1> sudo iptables -A INPUT -p tcp --sport 80 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --sport 80 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1> sudo iptables -A OUTPUT -p tcp --dport 80 -j ACCEPT -m state --state NEW,ESTABLISHED
BH1>
BH1> sudo iptables -A INPUT -p tcp -m state --state NEW,ESTABLISHED -m multiport --ports 22,23,3389
BH1>
BH1>
BH1>
BH3>sudo nft add table BH3
BH3>sudo nft add chain ip BH3 input { type filter hook input priority 0\; policy accept\; }
BH3>sudo nft add chain ip BH3 output { type filter hook output priority 0\; policy accept\; }
BH3>sudo nft add rule ip BH3 input tcp dport { 22,23,3389 } ct state { new, established } accept
BH3>sudo nft add rule ip BH3 input tcp sport { 22,23,3389 } ct state { new, established } accept
BH3>sudo nft add rule ip BH3 output tcp sport { 22,23,3389 } ct state { new, established } accept
BH3>sudo nft add rule ip BH3 output tcp dport { 22,23,3389 } ct state { new, established } accept
BH3>sudo nft add chain ip BH3 input { type filter hook input priority 0\; policy drop\; }
BH3>sudo nft add chain ip BH3 output { type filter hook output priority 0\; policy drop\; }
BH3>sudo nft insert rule ip BH3 output icmp type echo-request ip daddr 10.10.0.40 accept
BH3>sudo nft insert rule ip BH3 input icmp type echo-reply ip saddr 10.10.0.40 accept
BH3>sudo nft insert rule ip BH3 output icmp type echo-reply ip daddr 10.10.0.40 accept
BH3>sudo nft insert rule ip BH3 input icmp type echo-request ip saddr 10.10.0.40 accept
BH3>sudo nft add rule ip BH3 input tcp dport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 input tcp sport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 input udp dport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 input udp sport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 output tcp dport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 output tcp sport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 output udp dport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 output udp sport { 5050,5150 } accept
BH3>sudo nft add rule ip BH3 output/input tcp dport/sport { 80 } ct state { new, established } accept
BH3>
 sudo iptables -t nat -A POSTROUTING -o eth1 -j SNAT --to 192.168.1.10








Network Based filtering
Standard and extended ACLs
Standard is 1-99 and 1300-1999
Only filters on source address
Go as CLOSE to the destination as possible
Extended is 100-199 and 2000-2699
Can filter on Source, Destination, protocol, icmp type/code, and tcp/udp port
Go as CLOSE to the source as possible

IDS or IPS
Placement
Recognition Methods
        Signature - We know exactly what is looks like
        Heuristic aka Behavioral - Looking at how it acts and abnormal behavior outside of the baseline

Snort IDS/IPS Rule - Header
[action] [protocol] [s.ip] [s.port] [direction] [d.ip] [d.port] ( match conditions ;)


    Action - such as alert, log, pass, drop, reject
    Protocol - includes TCP, UDP, ICMP and others
    Source IP address - single address, CIDR notation, range, or any
    Source Port - one, multiple, any, or range of ports
    Direction - either inbound or in and outbound
    Destination IP address - options mirror Source IP
    Destination port - options mirror Source port

Snort IDS/IPS General rule options:
    msg - specifies the human-readable alert message
    reference - links to external source of the rule
    sid - used to uniquely identify Snort rules
    rev - uniquely identify revisions of Snort rules
    Classtype - used to describe what a successful attack would do
    priority - level of concern (1 - really bad, 2 - badish, 3 - informational)
    metadata - allows a rule writer to embed additional information about the rule

Snort IDS/IPS Payload detection options:
    content - looks for a string of text.
    |binary data| - to look for a string of binary HEX
    nocase - modified content, makes it case insensitive
    depth - specify how many bytes into a packet Snort should search for the specified pattern
    distance - how far into a packet Snort should ignore before starting to search for the specified pattern
        relative to the end of the previous pattern match
    within - modifier that makes sure that at most N bytes are between pattern matches using the content keyword
    offset - skips a certain number of bytes before searching (i.e. offset: 12)
Failed IDS/IPS
    Fail open
    Fail close
Attacking & Evading IDS/IPS
Based on Delta between devices
    Insertion Attack
        IDS accepts packet
        Host will not accept packet
    Evasion Attacking
        IDS does not accept packet
        Host will accept packet

Network Traffic Filtering Complete

Check intel on the CTF server for new information regarding mission tasks

Snort IDS/IPS Thresholding and suppression options:
    type [limit | threshold | both]
        limit alerts on the 1st event during defined period then ignores the rest.
        Threshold alerts every [x] times during defined period.
        Both alerts once per time internal after seeing [x] amount of occurrences of event. It then ignores all        other events during period.
    track [by_src | by_dst] - rate is tracked either by source IP address, or destination IP address
    count [#] - number of rule matching in [s] seconds that will cause event_filter limit to be exceeded
    seconds [seconds] - time period over which count is accrued. [s] must be nonzero value

Snort rule example
    Look for anonymous ftp traffic:
    alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; sid:2121; )
    This will cause the pattern matcher to start looking at byte 6 in the payload)
    alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; offset:5; sid:2121; )
    This will search the first 14 bytes of the packet looking for the word “anonymous”.
    alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; depth:14; sid:2121; )
    Deactivates the case sensitivity of a text search.
    alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; nocase; sid:2121; )

Rule Header
    ICMP ping sweep
    alert icmp any any -> 10.1.0.2 any (msg: "NMAP ping sweep Scan"; dsize:0; sid:10000004; rev: 1; )
    Look for a specific set of Hex bits (NoOP sled)
    alert tcp any any -> any any (msg:"NoOp sled"; content: "|9090 9090 9090|"; sid:9090; rev: 1; )
    Incorrect telnet login attempt
    alert tcp any 23 -> any any (msg:"TELNET login incorrect"; content:"Login incorrect";
    flow:established,from_server; classtype:bad-unknown; sid:2323; rev:6; )
Failed IDS/IPS
    Fail open
    Fail close
Attacking & Evading IDS/IPS
Based on Delta between devices
    Insertion Attack
        IDS accepts packet
        Host will not accept packet
    Evasion Attacking
        IDS does not accept packet
        Host will accept packet
Network Traffic Filtering Complete
Check intel on the CTF server for new information regarding mission tasks






snort --version +
sudo snort -D -l /var/log/snort/ -c /etc/snort/snort.conf
sudo cat /var/log/snort/alert
sudo tcpdump -ntr /var/log/snort/snort.log.1698843756 | awk '{print $2} {print $4}' | sort | uniq -c
sudo snort -r /var/log/snort/snort.log.1698843756
sudo snort -D -l /var/log/snort/ -c /etc/snort/snort.conf -n 6


Capstone notes, open TCP port waiting for a connection and use a Python3 TCP stream sender, .25 hint-03b
Bazinga is hint-03b


10.1.1.11 has the webservice on the RFC (probably 1918) that governs Private IPv4 addressing
There's a PCAP saved in the share folder of this machine


IH> ssh net5_student10@10.50.41.66 -p 7777 -L 51005:10.2.2.7:23 -NT
IH> telnet 127.0.0.1 51005
CAP7> ssh net5_student10@10.2.2.6 -p 7777 -R 51098:127.0.0.1:2222 -NT
IH> ssh net5_comrade10@127.0.0.1 -p 51006
IH> ssh net5_student10@10.50.41.66 -p 7777 -L 51006:127.0.0.1:51098 -NT
IH> ssh net5_comrade10@127.0.0.1 -p 51006 -D 9050 -NT
IH> ssh net5_comrade10@127.0.0.1 -p 51006 -L 51007:10.10.10.140:301 -NT
IH> ssh net5_student1010@127.0.0.1 -p 51007 -D 9050 -NT
IH> ssh net5_comrade10@127.0.0.1 -p 51006 -L 51007:10.10.10.167:404 -NT
